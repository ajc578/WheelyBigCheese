package userInterface;

import java.util.ArrayList;

import account.Account;
import account.CharacterParts;
import account.Protocol;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.NumberBinding;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.RowConstraints;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.stage.Screen;
import javafx.stage.Stage;
import presentationViewer.ExceptionFx;
/**
 * A Class which builds the graphical user interface for the social menu.
 * <p>
 * The social menu displays the following:
 * <ul>
 * <li>The user's Friend List</li>
 * <li>A Search bar and a Search Result List</li>
 * <li>A Leaderboard comparing the user's stats with their Friends</li>
 * <li>The user's Avatar and Stat Card</li>
 * <li>The Avatar and Stat Card of the selected Friend/SearchResult account</li>
 * </ul>
 * <p>
 * The social menu future features will include:
 * <p>
 * <ul>
 * <li>The MegaFit minigame to compete against your friends</li>
 * <li>A live messenger for communicating with your friends</li>
 * <li>The ability to send your own created workouts to your friends</li>
 * </ul>
 * <p>
 * <h6>Class description</h6>
 * <p>
 * The data used to fill the graphic interface is retrieved from both the user's local
 * account object/file and the server's. Before the interface is built, the back end 
 * communicates with the server to retrieve the current user's friend accounts. This means
 * that they always get the most recent progress of their friends. Also the server's directory
 * is searched for accounts matching or containing the specified search String and the results
 * are returned to the search list area. In the future there will be the option to challenge
 * your friends to the MegaFit minigame and a live messenger to complement this.
 * 
 * <p> <STRONG> Generated by </STRONG> <p>
 * JAXB
 * <p> <STRONG> Developed by </STRONG> <p>
 * Oliver Rushton
 * <p> <STRONG> Tested by </STRONG> <p>
 * Oliver Rushton
 * <p> <STRONG> Developed for </STRONG> <p>
 * BOSS
 * @author Oliver Rushton
 * 
 */
public class SocialMenu extends AnchorPane implements Controllable {


	private StackPaneUpdater screenParent;
	private Main mainApp;
	private ArrayList<Account> friendsList = new ArrayList<Account>();
	private ArrayList<Account> searchList = new ArrayList<Account>();
	
	/*VBox containers for sub-menu selection*/
	private VBox leaderboardContainer = new VBox();
	private VBox buttonsContainer = new VBox();
	private VBox searchContainer = new VBox();
	private VBox friendsListContainer = new VBox();
	private BorderPane editFriendsContainer = new BorderPane();
	private VBox liveArea = new VBox();
	private BorderPane searchFriendContainer = new BorderPane();
	
	/**
	 * contains the Avatar and Stats of the friend clicked on in the friend list
	 */
	private BorderPane avatarAndStats = new BorderPane();
	
	/**
	 * HBox container for overall content display - added to SocialMenu VBox*/
	private GridPane content = new GridPane();
	/**
	 * The search bar
	 */
	private TextField searchFriend;
	
	/**Target account set from clicked on row*/
	private Account targetAccount;
	
	/**Add and Delete Buttons for friendsList*/
	private Button friendButton = new Button();
	
	/**The users Leaderboard table
	 * @see Leaderboard*/
	private Leaderboard leaderboard;
	
	/**
	 * The Constructor sets the dimensions of the containers and there elements to fit with
	 * the aspect ratio of the screen the application is running on. Buttons are then set
	 * to swap between the search window and friends list. The search functionality is initialised
	 * and the add/remove friend buttons have their actions set.
	 * <p>
	 * Also at the start, the friends accounts are retrieved from the server directory
	 * in order to fill the content of the layout areas.
	 * 
	 * @param width the width of the layout area to which the social menu is added.
	 * @param height the height of the layout area to which the social menu is added.
	 */
	public SocialMenu(double width, double height){
		//retrieve friend accounts from the server directory
		obtainFriendAccounts();
		
		/*Initialise the swappable areas*/
		liveArea.getChildren().add(editFriendsContainer);
		/*Set default dimensions of the liveArea and its children*/
		double screenWidth = Screen.getPrimary().getVisualBounds().getWidth();
		double screenHeight = Screen.getPrimary().getVisualBounds().getHeight();
		//setting the minimum and maximum dimensions to the same forces the layout
		//managers to be a set size
		liveArea.setMinWidth(screenWidth*0.35);
		liveArea.setMinHeight(screenHeight*0.35);
		liveArea.setMaxWidth(screenWidth*0.35);
		liveArea.setMaxHeight(screenHeight*0.35);
		
		editFriendsContainer.setMinWidth(screenWidth*0.3);
		editFriendsContainer.setMinHeight(screenHeight*0.3);
		editFriendsContainer.setMaxWidth(screenWidth*0.35);
		editFriendsContainer.setMaxHeight(screenHeight*0.35);
		
		searchFriendContainer.setMinWidth(screenWidth*0.3);
		searchFriendContainer.setMinHeight(screenHeight*0.3);
		searchFriendContainer.setMaxWidth(screenWidth*0.35);
		searchFriendContainer.setMaxHeight(screenHeight*0.35);
		
		leaderboardContainer.setMinWidth(screenWidth*0.35);
		leaderboardContainer.setMinHeight(screenHeight*0.35);
		leaderboardContainer.setMaxWidth(screenWidth*0.35);
		leaderboardContainer.setMaxHeight(screenHeight*0.35);
		
		/*Set up grid for buttons */
		GridPane grid = new GridPane();
		grid.setAlignment(Pos.CENTER);
		grid.setHgap(10);
		grid.setVgap(10);
		grid.setPadding(new Insets(25, 25, 25, 25));
		
		Button addFriend = new Button("Search");
		Button editFriends = new Button("View Friends");
		addFriend.setPrefSize(120, 40);
		editFriends.setPrefSize(120, 40);
		//add the buttons
		grid.add(addFriend, 0, 0);
		grid.add(editFriends, 0, 1);
		//add to the button container
		buttonsContainer.getChildren().add(grid);
		
		/*ActionListeners for buttons*/
		addFriend.setOnAction(new EventHandler<ActionEvent>(){
		@Override
		public void handle(ActionEvent e){
			liveArea.getChildren().clear();
			liveArea.getChildren().add(searchContainer);
		}
		});
		
		editFriends.setOnAction(new EventHandler<ActionEvent>(){
		@Override
		public void handle(ActionEvent e){
			liveArea.getChildren().clear();
			liveArea.getChildren().add(editFriendsContainer);
		}
		});
		
		/*Leaderboard*/
		leaderboard = new Leaderboard(generateLeaderboardContent());
		leaderboard.setId("Leaderboard-SM");
		
		Label leaderboardTitle = new Label("Leaderboard");
		leaderboardTitle.getStyleClass().add("featureTitle");
		leaderboardContainer.setAlignment(Pos.CENTER);
		leaderboardContainer.getChildren().addAll(leaderboardTitle,leaderboard);
		
		
		/*Search friends*/
		searchFriend = new TextField();
		searchFriend.setPromptText("Search for a friend username, name or email...");
		TextArea searchResults = new TextArea();
		searchResults.setEditable(false);
		
		searchFriend.setOnKeyPressed(new EventHandler<KeyEvent>()
	    {
	        @Override
	        public void handle(KeyEvent ke)
	        {
	            if (ke.getCode().equals(KeyCode.ENTER))
	            {
	            	obtainSearchResult(searchFriend.getText());
	            	displaySearchList();
	            }
	        }
	    });
		
		/*Set Event Handler for the friendButton*/
		friendButton.setOnAction(event -> {
			if (friendButton.getText().startsWith("Add")) {
				System.out.println("SocialMenu: Add friend button pressed!");
				friendsList.add(targetAccount);
				updateServerAccount(targetAccount.getUsername(),true);
				displayEditFriendsList();
				friendButton.setText("Remove from\nFriend List");
				leaderboard.setData(generateLeaderboardContent());
			} else if (friendButton.getText().startsWith("Remove")) {
				System.out.println("SocialMenu: Remove friend button pressed!");
				ArrayList<Account> tempAccList = new ArrayList<Account>();
				ArrayList<String> tempStrList = new ArrayList<String>();
				for (Account i : friendsList) {
					if (!i.getUsername().equals(targetAccount.getUsername())) {
						tempAccList.add(i);
						tempStrList.add(i.getUsername());
					}
				}
				friendsList.clear();
				friendsList = tempAccList;
				updateServerAccount(targetAccount.getUsername(),false);
				displayEditFriendsList();
				friendButton.setText("Add to\nFriend List");
				leaderboard.setData(generateLeaderboardContent());
			}
		});
		
		//create title label for search container
		Label searchTitle = new Label("Search for a friend");
		searchTitle.setId("SearchTitle-SM");
		searchContainer.getChildren().addAll(searchTitle,searchFriend, searchFriendContainer);
		
		/*Friends list*/
		ScrollPane friendsList = new ScrollPane();
		friendsListContainer.getChildren().add(friendsList);
		
		/*Displays the user's friend list*/
		displayEditFriendsList();
		
		/*Add all content to screen*/
		AnchorPane.setBottomAnchor(avatarAndStats, 10.0);
		AnchorPane.setLeftAnchor(avatarAndStats, 10.0);
		this.getChildren().add(avatarAndStats);
		
		GridPane localAvatarAndStats = createLocalStatCard();
		AnchorPane.setBottomAnchor(localAvatarAndStats, 10.0);
		AnchorPane.setRightAnchor(localAvatarAndStats, 10.0);
		this.getChildren().add(localAvatarAndStats);

		ColumnConstraints genericColumn = new ColumnConstraints();
		ColumnConstraints fillerColumn = new ColumnConstraints();
		fillerColumn.setHgrow(Priority.ALWAYS);
		content.getColumnConstraints().add(genericColumn);
		content.getColumnConstraints().add(fillerColumn);
		content.getColumnConstraints().add(genericColumn);
		content.getColumnConstraints().add(fillerColumn);
		content.getColumnConstraints().add(genericColumn);

		content.add(buttonsContainer, 0, 0);
		content.add(liveArea, 2, 0);
		content.add(leaderboardContainer, 4, 0);

		this.getChildren().add(content);

		AnchorPane.setTopAnchor(content, 5.0);
		AnchorPane.setLeftAnchor(content, 5.0);
		AnchorPane.setRightAnchor(content, 5.0);

	}
	/**
	 * Adds all the account stats of the user's friends to the
	 * observable list which is used to fill the contents of the
	 * leaderboard table. The local user's stats are also added
	 * to allow for comparison.
	 * 
	 * @return An <code>ObservableList</code> of the friends list statistics.
	 * @see ObservableList
	 * @see User
	 * @see #createUser(Account)
	 */
	private ObservableList<User> generateLeaderboardContent() {
		ArrayList<User> temp = new ArrayList<User>();
		//iterate through each account in the friends list and add the data to the user list
		for (Account i : friendsList) {
			temp.add(createUser(i));
		}
		Account myAccount = Main.account;
		//add the local account stats as well
		temp.add(new User(myAccount.getUsername(), myAccount.getLevel(), myAccount.getXp(),
						  myAccount.getSkillPoints(), myAccount.getGainz()));
		ObservableList<User> data = FXCollections.observableArrayList(temp);
		return data;
	}
	/**
	 * Creates a <code>User</code> object from the account provided.
	 * This object contains all the relevant statistics of that account to
	 * display in the leaderboard.
	 * 
	 * @param userAcc the account to extract the statistics from.
	 * @return The extracted statistics as a <code>User</code> object.
	 * @see User
	 */
	private User createUser(Account userAcc) {
		//sums the accounts total skill points (spent and unspent)
		int totalSkillz = userAcc.getSkillPoints() +
						  userAcc.getCharacterAttributes().getStrength() +
						  userAcc.getCharacterAttributes().getSpeed() +
						  userAcc.getCharacterAttributes().getAgility() +
						  userAcc.getCharacterAttributes().getEndurance();
		//create the user
		User user = new User(userAcc.getUsername(), userAcc.getLevel(), userAcc.getXp(),
							 totalSkillz, userAcc.getGainz());

		return user;
	}
	/**
	 * This method either adds or removes the input username from the local user's 
	 * friend list stored in their account. Then the updated account is returned
	 * from the <code>ClientSide</code>. An <code>Alert</code> is raised if the
	 * server/client communications encountered an error.
	 * 
	 * @param username the username of the friend you want to add/remove.
	 * @param add if true, then the username is added to the friends account, or removed otherwise.
	 */
	private void updateServerAccount(String username, boolean add) {
		try{
			//check the user is connected to the server still
			if (Main.serverDetected && Main.client.isAccessible()) {
				//send the add or remove request protocol to the server
				if (add)
					Main.client.addFriend(username);
				else
					Main.client.removeFriend(username);
				while (true) {
					//retrieve the success of the protocol
					String output = Main.client.receive();
					if (output.equals(Protocol.SUCCESS)) {
						Main.account = Main.client.getAccount();
						break;
					} else if (output.startsWith(Protocol.ERROR)) {
						//generate errors if the servers account cannot be updated.
						ExceptionFx except = new ExceptionFx(AlertType.WARNING, "Save Error",
								 "You're friend list wasn't updated in the server server.",
								 "Try to restart the application to reconnect.",
								 (Stage) this.getScene().getWindow());
						except.show();
						break;
					}
				}
			} 
		} catch (Exception e){
			ExceptionFx except = new ExceptionFx(AlertType.ERROR, "Server Connection Error",
					 "The server encountered an error while trying to edit your friends list.",
					 "You may have to restart the application to access the social features.",
					 (Stage) this.getScene().getWindow());
			except.show();
		}
	}
	/**
	 * Retrieves the list of related accounts from the server directory to the 
	 * users search input String. Also generates an <code>Alert</code> to inform the
	 * user of an empty search result.
	 * 
	 * @param search the input String to search the server directory with.
	 */
	private void obtainSearchResult(String search) {
		try{
			//check the user is still connected to the server
			if (Main.serverDetected && Main.client.isAccessible()) {
				//send the search request to the server
				Main.client.searchFriend(search);
				while (true) {
					//retrieve the search results from the ClientSide
					String output = Main.client.receive();
					if (output.equals(Protocol.SUCCESS)) {
						searchList = Main.client.getFriendsList();
						break;
					} else if (output.startsWith(Protocol.ERROR)) {
						//generate alert to warn user of an empty search result
						ExceptionFx except = new ExceptionFx(AlertType.WARNING, "Search Result",
								 "There were no similar accounts found to the text input.",
								 "Either the target account doesn't exist, or you have made"
								 + " a spelling mistakes in the text input.\nPlease try again.",
								 (Stage) this.getScene().getWindow());
						except.show();
						break;
					}
				}
			} 
		} catch (Exception e){
			ExceptionFx except = new ExceptionFx(AlertType.ERROR, "Server Connection Error",
					 "The server encountered an error while trying to retrieve the search results.",
					 "You may have to restart the application to access the social features.",
					 (Stage) this.getScene().getWindow());
			except.show();
		}
	}
	/**
	 * Retrieves a list of the user's friend's accounts from the
	 * server.
	 */
	private void obtainFriendAccounts() {
		try{
			//check that the user is still connected to the server
			if (Main.serverDetected && Main.client.isAccessible()) {
				//send the get friends request to the server
				Main.client.findFriends();
				while (true) {
					//wait to obtain the results and then add the list to the friends list.
					String output = Main.client.receive();
					if (output.equals(Protocol.SUCCESS)) {
						friendsList = Main.client.getFriendsList();
						break;
					} else if (output.startsWith(Protocol.ERROR)) {
						System.out.println("Error returned in SocialMenu: " + output);
						break;
					}
				}
			} 
		} catch (Exception e){
			ExceptionFx except = new ExceptionFx(AlertType.ERROR, "Server Connection Error",
					 "The server encountered an error while trying to retrieve your friends list.",
					 "You may have to restart the application to access the social features.",
					 (Stage) this.getScene().getWindow());
			except.show();
		}
	}
	/**
	 * Creates the graphics and details to display in the user's friend list. The
	 * data displayed is retrieved from the <code>friendList</code> field.
	 */
	private void displayEditFriendsList() {
		//clear previous friend list
		editFriendsContainer.getChildren().clear();
		//creates the titles of each column
		editFriendsContainer.setTop(createFriendsListTitleRow(editFriendsContainer,0));
		ScrollPane friendScroll = new ScrollPane();
		//sets the size of the scroll pane to fill the friend list container
		friendScroll.minWidthProperty().bind(editFriendsContainer.widthProperty());
		friendScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		editFriendsContainer.setCenter(friendScroll);
		VBox scrollContent = new VBox();
		scrollContent.minWidthProperty().bind(editFriendsContainer.widthProperty());
		//adds the friend details to the friend list
		populateFriendTable(scrollContent);
		friendScroll.setContent(scrollContent);
	}
	/**
	 * Creates the graphics and details to display in the search result list. The
	 * data displayed is retrieved from the <code>searchList</code> field previously set.
	 */
	private void displaySearchList() {
		//creates the titles for each column of data
		searchFriendContainer.setTop(createFriendsListTitleRow(searchFriendContainer,1));
		ScrollPane searchScroll = new ScrollPane();
		searchScroll.minWidthProperty().bind(searchFriendContainer.widthProperty());
		searchScroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		searchFriendContainer.setCenter(searchScroll);
		VBox scrollContent = new VBox();
		scrollContent.minWidthProperty().bind(searchFriendContainer.widthProperty());
		//add the search result details to the search result list
		populateSearchTable(scrollContent);
		searchScroll.setContent(scrollContent);
	}
	/**
	 * Creates a StackPane containing the layered images from the <code>CharacterParts</code>
	 * provided. This constructs the avatar for a particular account.
	 * 
	 * @param source the <code>CharacterParts</code> containing all the paths for the avatar's hair, eyes and body.
	 * @param sizeBinding used to bind the width or height dimension of the avatar
	 * @param inTable determines whether the <code>DoubleBinding</code> provided is meant to bind the 
	 * 				  width or height of the images.
	 * @return An avatar constructed from the character parts provided.
	 */
	private StackPane createAvatarImage(CharacterParts source, DoubleBinding sizeBinding, boolean inTable) {
		StackPane imageContent = new StackPane();
		//set all images from the image paths stored in the account
		ImageView bodyImage = new ImageView(new Image("res/images/BaseCharacter.png"));
		System.out.println("SocialMenu: createAvatarImage: hair source: " + source.getHairSource());
		ImageView hairImage = new ImageView(new Image(source.getHairSource()));
		ImageView eyesImage = new ImageView(new Image(source.getEyesSource()));
		//Bind all Fit dimensions to the parameter width 
		if (inTable) {
			bodyImage.fitWidthProperty().bind(sizeBinding);
			hairImage.fitWidthProperty().bind(sizeBinding);
			eyesImage.fitWidthProperty().bind(sizeBinding);
		} else {
			bodyImage.fitHeightProperty().bind(sizeBinding);
			hairImage.fitHeightProperty().bind(sizeBinding);
			eyesImage.fitHeightProperty().bind(sizeBinding);
		}
		//set scaling smooth and preserve the aspect ratio of each image
		bodyImage.setPreserveRatio(true);
		hairImage.setPreserveRatio(true);
		eyesImage.setPreserveRatio(true);
		bodyImage.setSmooth(true);
		hairImage.setSmooth(true);
		eyesImage.setSmooth(true);
		
		imageContent.getChildren().add(bodyImage);
		imageContent.getChildren().add(eyesImage);
		imageContent.getChildren().add(hairImage);
		
		return imageContent;
	}
	/**
	 * Create titles for each column of data in the user's friend list.
	 * 
	 * @param container the <code>BorderPane</code> to add the title row to.
	 * @param titleIndex Indicates whether this title is for a friends list or a search result list.
	 * @return The title row.
	 */
	private GridPane createFriendsListTitleRow(BorderPane container, int titleIndex) {
		GridPane row = new GridPane();

		ColumnConstraints column1 = new ColumnConstraints();
		//bind the 4 column widths to a quarter of the total grid pane width.
		NumberBinding columnWidthBind = container.widthProperty().multiply(0.25);
		column1.minWidthProperty().bind(columnWidthBind);
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		//set the name of the list
		Label editTitle = null;
		if (titleIndex == 0)
			editTitle = new Label("Friends List");
		else if (titleIndex == 1)
			editTitle = new Label("Search Results");
		editTitle.getStyleClass().add("featureTitle");
		GridPane.setHalignment(editTitle, HPos.CENTER);
		row.add(editTitle, 0, 0, 4, 1);
		//set the column title labels
		Label imageLabel = new Label("Image");
		Label userNameLabel = new Label("User Name");
		Label firstNameLabel = new Label("First Name");
		Label lastNameLabel = new Label("Last Name");
		imageLabel.getStyleClass().add("columnTitle");
		userNameLabel.getStyleClass().add("columnTitle");
		firstNameLabel.getStyleClass().add("columnTitle");
		lastNameLabel.getStyleClass().add("columnTitle");
		//position the title labels in the center of each column
		GridPane.setHalignment(imageLabel, HPos.CENTER);
		GridPane.setHalignment(userNameLabel, HPos.CENTER);
		GridPane.setHalignment(firstNameLabel, HPos.CENTER);
		GridPane.setHalignment(lastNameLabel, HPos.CENTER);

		row.add(imageLabel, 0, 1);
		row.add(userNameLabel, 1, 1);
		row.add(firstNameLabel, 2, 1);
		row.add(lastNameLabel, 3, 1);

		return row;
	}
	/**
	 * Creates an account row element for the search result or friends list table.
	 * 
	 * 
	 * @param scrollContent the container to add the row to.
	 * @param account the account used to fill the row's data
	 * @param index the index referencing the element in the <code>friendList</code> or <code>searchList</code>.
	 * @return an indexed grid pane containing the created row.
	 * @see IndexGridPane
	 */
	private IndexGridPane createRow(VBox scrollContent, Account account, int index) {
		IndexGridPane row = new IndexGridPane(index);
		ColumnConstraints column1 = new ColumnConstraints();
		column1.minWidthProperty().bind(scrollContent.widthProperty().multiply(0.25));
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		row.getColumnConstraints().add(column1);
		//creates the avatar with the correct dimensions
		StackPane avatar = createAvatarImage(account.getCharacterAttributes().getCharacterSource(), 
											 scrollContent.widthProperty().multiply(0.1),true);
		//adds the other user data to the remaining rows
		Label username = new Label(account.getUsername());
		Label firstname = new Label(account.getFirstName());
		Label lastname = new Label(account.getSurname());

		GridPane.setHalignment(avatar, HPos.CENTER);
		GridPane.setHalignment(username, HPos.CENTER);
		GridPane.setHalignment(firstname, HPos.CENTER);
		GridPane.setHalignment(lastname, HPos.CENTER);

		row.add(avatar, 0, 0);
		row.add(username, 1, 0);
		row.add(firstname, 2, 0);
		row.add(lastname, 3, 0);

		setNodeCursor(row);
		
		return row;
	}
	/**
	 * Sets the action for when a row in the friend list or search results table is clicked.
	 * The action is the same for both the friend table and search table, but the list from where
	 * the details are obtained is dependent on the table type. The action creates the selected 
	 * row's account avatar and stat card to compare against the local user's stat crad.
	 * <p>
	 * The element in the corresponding list is referenced by the index of the <code>IndexGridPane</code>.
	 * 
	 * @param row the row to set the click action for.
	 * @param listChoice Indicates which list to use to create the avatar and stat card. 
	 * 					 0 - friends list, 1 - search list.
	 */
	private void addClickListener(IndexGridPane row, int listChoice) {
		if (listChoice == 0) {
			row.setOnMouseClicked(event -> {
				//present the friends account stat card and avatar
				avatarAndStats.getChildren().clear();
				targetAccount = friendsList.get(row.getIndex());
				avatarAndStats.setCenter(createMoreFriendDetails(targetAccount));
				friendButton.setText("Remove from\nFriend List");
			});
		} else if (listChoice == 1) {
			row.setOnMouseClicked(event -> {
				//present the search result account stat card and avatar
				avatarAndStats.getChildren().clear();
				targetAccount = searchList.get(row.getIndex());
				friendButton.setText("Add to\nFriend List");
				//checks whether the user already has this account in their friend list in order
				//to set the add/remove text for the friend button.
				for (Account i : friendsList) {
					if (i.getUsername().equals(targetAccount.getUsername())) {
						friendButton.setText("Remove from\nFriend List");
						break;
					}
				}
				avatarAndStats.setCenter(createMoreFriendDetails(searchList.get(row.getIndex())));
			});
		}
	}
	/**
	 * Creates all the rows to add to the friend table.
	 * 
	 * @param scrollContent the container to add the rows to.
	 */
	private void populateFriendTable(VBox scrollContent) {
		for (int i = 0; i < friendsList.size(); i++) {
			IndexGridPane row = createRow(scrollContent,friendsList.get(i),i);
			scrollContent.getChildren().add(row);
			//set the action of the row when clicked
			addClickListener(row,0);
		}

	}
	/**
	 * Creates all the rows to add the the search result table.
	 * 
	 * @param scrollContent the container to add the rows to.
	 */
	private void populateSearchTable(VBox scrollContent) {
		System.out.println("SocialMenu: populateSearchTable: search list size: " + searchList.size());
		for (int i = 0; i < searchList.size(); i++) {
			System.out.println("SocialMenu: populateSearchTable: search list content: " + searchList.get(i));
			IndexGridPane row = createRow(scrollContent,searchList.get(i),i);
			scrollContent.getChildren().add(row);
			//set the action of the row when clicked
			addClickListener(row,1);
		}
	}
	/**
	 * Constructs the local users account stat card and avatar.
	 * 
	 * @return The local users account stat card and avatar in a <code>GridPane</code>.
	 */
	private GridPane createLocalStatCard() {
		GridPane friendPane = new GridPane();
		double screenWidth = Screen.getPrimary().getVisualBounds().getWidth();
		double screenHeight = Screen.getPrimary().getVisualBounds().getHeight();
		friendPane.setMaxWidth(screenWidth*0.4);
		friendPane.setMaxHeight(screenHeight*0.4);
		friendPane.setMinWidth(screenWidth*0.4);
		friendPane.setMinHeight(screenHeight*0.4);
		
		ColumnConstraints column1 = new ColumnConstraints();
		column1.setMaxWidth(screenWidth*0.25);
		column1.setMinWidth(screenWidth*0.25);
		friendPane.getColumnConstraints().add(column1);
		ColumnConstraints column2 = new ColumnConstraints();
		column2.setMaxWidth(screenWidth*0.15);
		column2.setMinWidth(screenWidth*0.15);
		friendPane.getColumnConstraints().add(column2);

		RowConstraints row = new RowConstraints();
		row.setMinHeight(screenHeight*0.2);
		row.setMaxHeight(screenHeight*0.2);
		friendPane.getRowConstraints().add(row);
		friendPane.getRowConstraints().add(row);
		//add stat card to left hand column
		friendPane.add(generateStatCard(Main.account), 0, 0);
		//add avatar to right hand column
		friendPane.add(createAvatarImage(Main.account.getCharacterAttributes().getCharacterSource(),
						friendPane.heightProperty().multiply(1.0),false), 1, 0, 1, 2);

		return friendPane;
	}
	/**
	 * Creates the avatar and stat card of the selected account in the search/friends table.
	 * 
	 * @param friend the selected account to create the avatar/stat card for.
	 * @return the selected accounts avatar and stat card.
	 */
	private GridPane createMoreFriendDetails(Account friend) {
		GridPane friendPane = new GridPane();
		double screenWidth = Screen.getPrimary().getVisualBounds().getWidth();
		double screenHeight = Screen.getPrimary().getVisualBounds().getHeight();
		friendPane.setMaxWidth(screenWidth*0.4);
		friendPane.setMaxHeight(screenHeight*0.4);
		friendPane.setMinWidth(screenWidth*0.4);
		friendPane.setMinHeight(screenHeight*0.4);

		ColumnConstraints column1 = new ColumnConstraints();
		column1.setMaxWidth(screenWidth*0.15);
		column1.setMinWidth(screenWidth*0.15);
		friendPane.getColumnConstraints().add(column1);
		ColumnConstraints column2 = new ColumnConstraints();
		column2.setMaxWidth(screenWidth*0.25);
		column2.setMinWidth(screenWidth*0.25);
		friendPane.getColumnConstraints().add(column2);

		RowConstraints row = new RowConstraints();
		row.setMinHeight(screenHeight*0.2);
		row.setMaxHeight(screenHeight*0.2);
		friendPane.getRowConstraints().add(row);
		friendPane.getRowConstraints().add(row);
		//add avatar to the left column
		friendPane.add(createAvatarImage(friend.getCharacterAttributes().getCharacterSource(),
						friendPane.heightProperty().multiply(1.0),false), 0, 0, 1, 2);
		//add stat card to the right column
		friendPane.add(generateStatCard(friend), 1, 0);
		
		GridPane.setHalignment(friendButton, HPos.CENTER);
		friendPane.add(friendButton, 1, 1);
		
		return friendPane;
	}
	/**
	 * Creates the stat card of the input account. The stat card shows the input accounts names,
	 * date of birth and email, as well as there current level, xp and gainz. Also the users stats
	 * in each skill tree are shown.
	 * 
	 * @param friend the account to create the stat card for.
	 * @return the created stat card.
	 */
	private GridPane generateStatCard(Account friend) {
		GridPane statCard = new GridPane();
		statCard.setHgap(5);
		statCard.setVgap(5);
		double screenWidth = Screen.getPrimary().getVisualBounds().getWidth();
		statCard.setMinWidth(screenWidth*0.25);
		
		Label cardTitle = new Label("Stat Card: " + friend.getUsername());
		cardTitle.getStyleClass().add("featureTitle");
		cardTitle.setAlignment(Pos.CENTER_LEFT);
		statCard.setId("StatCard-SM");
		//set the different column widths of the stat card
		ColumnConstraints column1 = new ColumnConstraints();
		column1.setMinWidth(statCard.getMinWidth()*0.25);
		ColumnConstraints column2 = new ColumnConstraints();
		column1.setMinWidth(statCard.getMinWidth()*0.35);
		ColumnConstraints column4 = new ColumnConstraints();
		column1.setMinWidth(statCard.getMinWidth()*0.15);
		statCard.getColumnConstraints().add(column1);
		statCard.getColumnConstraints().add(column2);
		statCard.getColumnConstraints().add(column1);
		statCard.getColumnConstraints().add(column4);
		//set all the labels and their styles for the stat card.
		Label firstnameTitle = new Label("First name:");
		firstnameTitle.getStyleClass().add("columnTitle");
		Label lastnameTitle = new Label("Last name:");
		lastnameTitle.getStyleClass().add("columnTitle");
		Label emailTitle = new Label("Email:");
		emailTitle.getStyleClass().add("columnTitle");
		Label dOBTitle = new Label("DOB:");
		dOBTitle.getStyleClass().add("columnTitle");
		
		Label firstnameLabel = new Label(friend.getFirstName());
		firstnameLabel.getStyleClass().add("statCardDetailsText");
		Label lastnameLabel = new Label(friend.getSurname());
		lastnameLabel.getStyleClass().add("statCardDetailsText");
		Label emailLabel = new Label(friend.getEmail());
		emailLabel.getStyleClass().add("statCardDetailsText");
		Label dOBLabel = new Label(friend.getDOB());
		dOBLabel.getStyleClass().add("statCardDetailsText");
		
		Label levelTitle = new Label("Level:");
		levelTitle.getStyleClass().add("columnTitle");
		Label xpTitle = new Label("XP:");
		xpTitle.getStyleClass().add("columnTitle");
		Label gainzTitle = new Label("Gainz:");
		gainzTitle.getStyleClass().add("columnTitle");
		
		Label levelLabel = new Label(Integer.toString(friend.getLevel()));
		levelLabel.getStyleClass().add("statCardDetailsText");
		Label xpLabel = new Label(Integer.toString(friend.getXp()));
		xpLabel.getStyleClass().add("statCardDetailsText");
		Label gainzLabel = new Label(Integer.toString(friend.getGainz()));
		gainzLabel.getStyleClass().add("statCardDetailsText");
		
		Label strengthTitle = new Label("Strength:");
		strengthTitle.getStyleClass().add("columnTitle");
		Label speedTitle = new Label("Speed:");
		speedTitle.getStyleClass().add("columnTitle");
		Label agilityTitle = new Label("Agility:");
		agilityTitle.getStyleClass().add("columnTitle");
		Label enduranceTitle = new Label("Endurance:");
		enduranceTitle.getStyleClass().add("columnTitle");
		
		Label strengthLabel = new Label(Integer.toString(friend.getCharacterAttributes().getStrength()));
		strengthLabel.getStyleClass().add("statCardDetailsText");
		Label speedLabel = new Label(Integer.toString(friend.getCharacterAttributes().getSpeed()));
		speedLabel.getStyleClass().add("statCardDetailsText");
		Label agilityLabel = new Label(Integer.toString(friend.getCharacterAttributes().getAgility()));
		agilityLabel.getStyleClass().add("statCardDetailsText");
		Label enduranceLabel = new Label(Integer.toString(friend.getCharacterAttributes().getEndurance()));
		enduranceLabel.getStyleClass().add("statCardDetailsText");
		//add the details to the stat card
		statCard.add(cardTitle, 0, 0, 4, 1);
		statCard.add(firstnameTitle,0,1);
		statCard.add(lastnameTitle,0,2);
		statCard.add(emailTitle,0,3);
		statCard.add(dOBTitle,0,4);
		statCard.add(firstnameLabel,1,1);
		statCard.add(lastnameLabel,1,2);
		statCard.add(emailLabel,1,3);
		statCard.add(dOBLabel,1,4);
		
		statCard.add(strengthTitle, 2, 1);
		statCard.add(speedTitle, 2, 2);
		statCard.add(agilityTitle, 2, 3);
		statCard.add(enduranceTitle, 2, 4);
		statCard.add(strengthLabel, 3, 1);
		statCard.add(speedLabel, 3, 2);
		statCard.add(agilityLabel, 3, 3);
		statCard.add(enduranceLabel, 3, 4);
		//sets an empty row
		Label filler = new Label(" ");
		statCard.add(filler, 0, 5, 4, 1);
		
		statCard.add(levelTitle,0,6);
		statCard.add(xpTitle,2,6);
		statCard.add(levelLabel,1,6);
		statCard.add(xpLabel,3,6);
		
		HBox gainzBox = new HBox();
		gainzBox.setSpacing(10.0);
		gainzBox.setAlignment(Pos.CENTER);
		gainzBox.getChildren().addAll(gainzTitle, gainzLabel);
		
		statCard.add(gainzBox, 0, 7, 4, 1);
		//position all of the labels in each cell
		GridPane.setHalignment(cardTitle, HPos.CENTER);
		GridPane.setHalignment(firstnameTitle, HPos.LEFT);
		GridPane.setHalignment(lastnameTitle, HPos.LEFT);
		GridPane.setHalignment(emailTitle, HPos.LEFT);
		GridPane.setHalignment(dOBTitle, HPos.LEFT);
		GridPane.setHalignment(firstnameLabel, HPos.CENTER);
		GridPane.setHalignment(lastnameLabel, HPos.CENTER);
		GridPane.setHalignment(emailLabel, HPos.CENTER);
		GridPane.setHalignment(dOBLabel, HPos.CENTER);
		GridPane.setHalignment(levelTitle, HPos.CENTER);
		GridPane.setHalignment(xpTitle, HPos.CENTER);
		GridPane.setHalignment(levelLabel, HPos.CENTER);
		GridPane.setHalignment(xpLabel, HPos.CENTER);
		
		GridPane.setHalignment(strengthTitle, HPos.LEFT);
		GridPane.setHalignment(speedTitle, HPos.LEFT);
		GridPane.setHalignment(agilityTitle, HPos.LEFT);
		GridPane.setHalignment(enduranceTitle, HPos.LEFT);
		
		GridPane.setHalignment(strengthLabel, HPos.CENTER);
		GridPane.setHalignment(speedLabel, HPos.CENTER);
		GridPane.setHalignment(agilityLabel, HPos.CENTER);
		GridPane.setHalignment(enduranceLabel, HPos.CENTER);

		return statCard; 
	}
	/**
	 * Sets the mouse icon to a click icon when hovering over the input node.
	 * 
	 * @param node the graphical element to set the above action for.
	 */
	public void setNodeCursor (Node node) {
		
		node.setOnMouseEntered(event -> setCursor(Cursor.HAND));
		node.setOnMouseExited(event -> setCursor(Cursor.DEFAULT));
	}

	@Override
	public void setScreenParent(StackPaneUpdater screenParent) {
		this.screenParent = screenParent;
	}

	@Override
	public void setMainApp(Main mainApp) {
		this.mainApp = mainApp;
	}
}
